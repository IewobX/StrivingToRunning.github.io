<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>my blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-13T12:02:43.919Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>徐博伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端小白的js总结---基础篇.md</title>
    <link href="http://yoursite.com/2017/12/13/%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%99%BD%E7%9A%84js%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87-md/"/>
    <id>http://yoursite.com/2017/12/13/前端小白的js总结-基础篇-md/</id>
    <published>2017-12-13T11:55:17.000Z</published>
    <updated>2017-12-13T12:02:43.919Z</updated>
    
    <content type="html"><![CDATA[<p>#####《参考JavaScript高级程序设计（第三版）》#####</p><p>#前端小白JS总结—基础篇#</p><p>###数据类型###<br>基本类型: number,string,boolean,null,undefined<br>基本类型间相互转化: Number(),String(),Boolean()<br>引用类型: Object, Array, RegExp,基本包装类型等，所有引用类型都是Object的实例<br>基本类型与引用类型的区别: 基本类型按值访问，引用类型按引用访问</p><blockquote><p>   动态的属性，引用类型可以添加属性，基本类型无法添加属性<br><a id="more"></a><br>   复制变量值，复制基本类型时会在变量对象上创建一个新值，复制引用类型时会         复制一份指针，指向存储在堆中的一个对象，两个变量实际上引用同一个对象。</p><p>   传递参数，在向参数传递引用类型值时，会把这个值在内存中的地址复制给一个         局部变量</p></blockquote><p>基本包装类型: Boolean(),String(),Number(),与其他引用类型相似，可以更好的操作基本类型。</p><blockquote><p>   Boolean类型 是与布尔值相对应的引用类型，可以这样调用构造函数并传入布尔值<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var boolean = new Boolean(false);</div></pre></td></tr></table></figure></p></blockquote><pre><code> 它经常造成人们的误解 例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var booleanFalse = new Boolean(false);  </div><div class="line">var result = booleanFalse&amp;&amp;true;  </div><div class="line">alert(reasult)//true</div></pre></td></tr></table></figure></code></pre><blockquote><p>   Number类型 是与数字值相对应的引用类型，创建方法同上<br>    toString()方法，返回几进制数值的字符串形式<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var num = 10;  </div><div class="line">console.log(num.toString());//&apos;10&apos;</div><div class="line">console.log(num.toString(2));//&apos;1010&apos;</div></pre></td></tr></table></figure></p></blockquote><pre><code>toFixed()方法，返回指定保留几位小数数值的字符串表示<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10.005;</div><div class="line">console.log(num.toFixed(2));//&apos;10.01&apos;</div></pre></td></tr></table></figure>toExponential()方法，返回以指数表示法表示的数值的字符串形式，参数表示输出         结果中的小数位数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">console.log(num.toExponential(1));//‘1.0e+1’</div></pre></td></tr></table></figure>toPrecision()方法，返回固定大小格式。</code></pre><blockquote><p>   String类型 是与字符串相对应的引用类型，创建方法同上<br>    length属性表示字符串长度<br>    访问字符串中特定字符的方法charAt()和charCodeAt()<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &apos;hello world&apos;;</div><div class="line">console.log(stringValue.charAt(1))//&apos;e&apos;</div><div class="line">console.log(stringValue.charCodeAt(1))//&apos;101&apos;</div></pre></td></tr></table></figure></p></blockquote><pre><code>concat()方法，用于字符串拼接<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &apos;hello&apos;;</div><div class="line">console.log(stringValue.concat(&apos;world&apos;,&apos;!&apos;));//&apos;hello world!&apos;</div></pre></td></tr></table></figure>基于子字符串创建新字符串的方法： slice(),substr(),substring(),substring()方法,用于提取字符串中介于两个指定下标之间的字符substr() 方法用于返回一个从指定位置开始的指定长度的子字符串。slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var test = &apos;hello world&apos;;</div><div class="line">console.log(test.slice(-3));         //rld</div><div class="line">console,log(test.substring(-3));   //hello world</div><div class="line">console,log(test.substr(-3));       //rld</div><div class="line">console,log(test.slice(3,-4));//lo w</div><div class="line">console,log(test.substring(3,-4));//hel</div><div class="line">console,log(test.substr(3,-4));//空字符串</div></pre></td></tr></table></figure>使用indexOf()和lastIndexOf()来查找字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &apos;hello world&apos;</div><div class="line">console,log(stringValue.indexOf(&apos;o&apos;,6));//7</div><div class="line">console,log(stringValue.lastIndexOf(&apos;o&apos;,6))//4</div></pre></td></tr></table></figure>trim()创建一个字符串副本，删除前置及后缀所有空格，返回结果字符串大小写转换： toUpperCase(),toLowerCase();字符串模式匹配方法：match(),search(),replace()替换,split()分割<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">text = &quot;cat bat sat fat&quot;;</div><div class="line">var result = text.replace(&apos;at&apos;,&apos;ond&apos;);</div><div class="line">console.log(result)//&apos;cond bat sat fat&apos;</div><div class="line">result = text.replace(/at/g,&apos;ond&apos;);</div><div class="line">console.log(result)//&apos;cond bond sond fond-&apos;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colorText = &apos;red,blue,green.yellow&apos;;</div><div class="line">var color1 = colorText.split(&apos;,&apos;);//[&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;,&apos;yellow&apos;]</div><div class="line">var color2 = colorText.split(&apos;,&apos;2);//[&apos;red&apos;,&apos;blue&apos;]</div></pre></td></tr></table></figure>localeCompare()用于比较两个字符串</code></pre><p>检测类型： 推荐使用instanceof</p><p>###作用域###</p><blockquote><p>   变量对象:每个执行环境都有一个与之相关联的变量对象,这个对象保存了环境         中定义的所有变量和函数.</p><p>   作用域链:当代码在一个环境中执行时,会创建一个变量对象的作用域链.在我看     来,作用域链可以看作是一个数组里面保存着一个或几个指向变量对象的指针,         其中第一个值是指向当前函数(或全局)的变量对象的指针,第二个值是指向外部     环境的变量对象的指针,第三个值是指向外部环境的外部环境的变量对象的指         针,直到全局执行环境.</p></blockquote><p>标识符的解析是沿着作用域链一级一级的搜索标识符的过程.搜索过程始终从作用域链的前端开始,逐级向后回溯,直到找到目标标识符为止.</p><p>###变量###<br>变量的定义使用var,let(es6)，松散类型（弱类型）声明前不加var或let表示直接声明全局变量<br>无块级作用域<br>变量提升，将变量提升到作用域顶端，但只是提升变量的声明，并不提升赋值。</p><p>###函数###<br>函数的定义使用function,const(es6)，没有重载</p><p>####函数声明####<br>即用<code>function functionName(){}</code>进行声明<br>函数声明提升，在执行代码前会先读取函数声明</p><p>####函数表达式####<br><code>var functionName = function(){}</code>形式<br>创建一个匿名函数，并将其赋值给变量functionName，没有函数提升。</p><blockquote><p>   闭包: 针对一个函数A，该函数A有权访问另一个函数B作用域中的变量，此时         就形成了一个闭包。<br>    <a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">参考阮一峰先生所写的闭包</a> </p><p>   this:指的是，调用函数的那个对象</p><p>   匿名函数:顾名思义,没有名字的函数,匿名函数的执行环境具有全局性,所以其         this通常指向window(在通过call()或apply()改变函数执行环境的情况下,this就会指向其他对象)<br>    模仿块级作用域:我们知道,js是没有块级作用域的,也就是说,在块级作用域中定义的变量实际上是在包含函数中创建的.匿名函数可以模拟块级作用域<code>(function(){})()</code>表示一个立即执行的匿名函数.</p><p>   私有变量:js中,任何函数中定义的变量都可以认为是私有变量,因为不能再函数          外部访问他们,私有变量包括函数的参数,局部变量和在函数内部定义的其他函         数.有权访问函数 私有变量和私有方法的 公有方法,称之为特权方法,这类似         java中的私有成员.<br>   静态私有变量 通过原型来实现静态.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#####《参考JavaScript高级程序设计（第三版）》#####&lt;/p&gt;
&lt;p&gt;#前端小白JS总结—基础篇#&lt;/p&gt;
&lt;p&gt;###数据类型###&lt;br&gt;基本类型: number,string,boolean,null,undefined&lt;br&gt;基本类型间相互转化: Number(),String(),Boolean()&lt;br&gt;引用类型: Object, Array, RegExp,基本包装类型等，所有引用类型都是Object的实例&lt;br&gt;基本类型与引用类型的区别: 基本类型按值访问，引用类型按引用访问&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   动态的属性，引用类型可以添加属性，基本类型无法添加属性&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/09/13/hello-world/"/>
    <id>http://yoursite.com/2017/09/13/hello-world/</id>
    <published>2017-09-13T12:09:29.954Z</published>
    <updated>2017-09-13T12:09:29.906Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内排序</title>
    <link href="http://yoursite.com/2017/09/13/%E5%86%85%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/09/13/内排序/</id>
    <published>2017-09-13T07:51:05.000Z</published>
    <updated>2017-09-13T08:19:33.471Z</updated>
    
    <content type="html"><![CDATA[<p><em>在排序过程中，若整个表都是放在内存中处理，排序时不涉及内、外存数据的交换，则称之为内排序。</em></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><em>插入排序的基本思想是：每一次将一个待排序的元素，按其关键字大小插入到已经排好序的字表中的适当位置，知道全部元素插入完成为止。</em><br><a id="more"></a></p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><strong>排序思路：</strong>假设待排序的元素放在数组R[0..n-1]中，排序过程中的某一时刻，R被划分成两个子区间R[0..i-1]和R<a href="刚开始i=1，有序区间只有R[0]一个元素">i..n-1</a>，其中，前一个子区间是已排好序的有序区，后一个子区间则是当前未排序的部分，不妨称其为无需区。直接插入排序的一趟操作是将当前无序区的开头元素R<a href="1&lt;=i&lt;=n-1">i</a>插入带有序区R[0..i-1]中的适当位置上，使R[0..i]变成新的有序区。<br>排序算法： <code>void InsertSort(RecType R[],int n){ int i,j; RecType tmp; for{i=1;i&lt;n;i++}{ tmp = R[i]; j=i-1; while(j&gt;=0&amp;&amp;tmp.key&lt;R[i].key){ R[j+1]=R[j]; j--; } R[j+1] = tmp; } }</code><br><strong>算法分析：</strong>直接插入排序由两重循环构成，对于具有n个元素的表，外循环要进行n-1(i取值范围：1~n-1)趟排序。在每一趟排序中，仅当待插入元素R[i].key&gt;=R[i-1].key(亦即大于等于R[0..i-1]中所有关键字)时,才无需进入内循环。若初始数据序列按关键字递增有序(以下简称“正序”)，则在每一趟排序中仅需进行一次关键字的比较，因为每趟排序均不进入内循环，故不会执行语句R[j+1]=R[j]，此时元素移动次数为2(tmp=R[i]与R[j+1]=tmp各算一次)。由此可知，正序时插入排序的关键字比较次数和元素移动次数均达到最小值Cmin和Mmin。反之，若初始数据序列按关键字递减有序(以下简称“反序”)，则每趟排序中，因为当前有序区R[0..i-1]中的关键字均大于待插元素R[i]的关键字，所以内循环需要将待插元素tmp的关键字和R[0..i-1]中全部的关键字进行比较，这里需要进行i次关键字比较；显然内循环里须将R[0..i-1]中所有元素后移(共(i-1)-0+1=i次)，外加tmp=R[i]与R[i+1]=tmp的两次移动，一趟排序所需的元素移动次数为i+2。由此可知，反序时插入排序的关键字比较次和元素移动次数均达到最大值Cmax和Mmax。由上述分析可知，当初始数据序列不同时，直接插入排序所耗费的时间是有很大差异的，最好的情况是标出态为正序，此时算法的时间复杂度为O(n)，最坏的情况是表初态为反序，相应的时间复杂度为O(n2)。容易证明，算法的平均复杂度为O(n2),这是因为将R<a href="1&lt;=i&lt;=i-1">i</a>插入到有序区R<a href="其中有i个元素">0..i-1</a>时，平均比较次数为i/2，平均移动次数为i/2+2，故平均时间复杂度约为O(n2)。</p><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p><strong>排序思路：</strong>直接插入排序将无序区中开头元素R<a href="1&lt;=i&lt;=n-1">i</a>插入到有序区R[0..i-1]中，此时可以采用折半查找的方法先在R[0..i-1]中找到插入位置，在通过移动元素的进行插入，这样的插入排序叫做折半插入排序或二分插入排序。 在R<a href="初始时low=0，high=i-1">low..high</a>中采用折半查找方法查找到插入R[i]的位置为R[high+1]，再将R[high+1..i-1]中元素后移一个位置，并置R[high+1]=R[i]。<br><strong>说明:</strong>和直接插入排序一样，折半插入排序每趟产生的有序区并不一定是全局有序区。<br>排序算法： <code>void Insert1(RecType R[],int n){ int i,j,low,high,mid; RecType tmp; for(i=0;i&lt;n;i++){ tmp = R[i]; low = 0;high = i-1; while(low&lt;=high){ mid = (low+high)/2; if(tmp.key&lt;R[mid].key){ high = mid-1; } else{ low = mid+1; } } for(j=i-1;j&gt;=high+1;j--) R[j+1] = R[j]; R[high+1] = tmp; } }</code><br><strong>算法分析：</strong>从上述算法中看到，当初始数据序列为正序时，关键字的比较次数并不能减少；当初始数据序列为反序时，关键字的比较次数也不会增加。折半插入排序的元素移动次数与直接插入排序相同，不同的仅是变分散移动为集合移动。在R[0..i-1]中查找插入R[i]的位置，折半查找的平均关键字比较次数为log2(i+1)-1,平均的元素移动次数为i/2+2，所以平均时间复杂度为O(n2)。就平均性能而言，折半查找由于顺序查找，所以折半插入排序也优于直接插入排序。折半插入排序的空间复杂度为O(1)。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><strong>排序思路：</strong>希尔排序实际上是一种分组插入的方法。其基本思想是：先取定一个小于n的整数d1作为第一个增量，把表的全部元素分成d1个组，所有相互之间距离为d1的倍数的元素放在同一个组中，在个组内进行直接插入排序；然后，取第二个增量d2(<d1)，重复上述的分组和排序过程，直至所取的增量dt=1(dt<dt-1<...<d2<d1)，即所有元素放在同一组中进行直接插入排序。 **说明：**希尔排序每趟并不产生有序区，在最后一趟排序结束前，所有元素并不一定归位。但是每趟排序完成后，数据越来越接近有序。="" **排序算法：**取d1="n/2，di+1=[di/2]时的希尔排序的算法如下：" ``void="" shellsort(rectype="" r[],int="" n){="" int="" i,j,jap;="" rectype="" tmp;="" gap="n/2;" while(gap="">0){ for(i=gap;i<n;i++){ tmp="R[i];" j="i-gap;" while(j="">=0&amp;&amp;tmp.key&lt;R[j].key){ R[j+gap] = R[j]; j=j-gap; } R[j+gap]=tmp; } gap=gap/2; } }``<br><strong>算法分析：</strong>希尔排序法的性能分析是一个复杂的问题，因为它的时间复杂度是所取增量序列的函数，而且到目前为止增量的选取无一定论。但无论增量如何选取，最后一个增量必须是1。如果按照上述取法，一般认为希尔算法的平均时间复杂度是O(n^1.3)。希尔排序的速度一般要比直接插入排序快。 希尔算法只是用i,j,gap,tmp四个辅助变量，与问题规模n无关，所以空间复杂度为O(1),也就是说，他是一个就地排序。</n;i++){></d1)，重复上述的分组和排序过程，直至所取的增量dt=1(dt<dt-1<...<d2<d1)，即所有元素放在同一组中进行直接插入排序。></p><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p><em>交换排序的基本思想：两两比较待排序元素的关键字，发现两个元素的次序相反时即进行交换，知道没有反序的元素为止。</em></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>排序思路：</strong>通过无需区中相邻元素间的关键字的比较和位置的交换，使关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”。整个过程是从最下面的元素开始，对每两个相邻的关键字进行比较，且使关键字较小的元素换至关键字较大的元素之上，使得经过一趟冒泡排序之后，关键字最小的元素到了最上端。接着，再在剩下的元素中找关键字次小的元素，并把它换到第二个位置。以此类推，一直到所有元素都有续为止。<br><strong>说明：</strong>冒泡排序每趟产生的有序区一定是全局有序区，也就是说每趟产生的有序区中所有元素都归位了。<br>排序算法： <code>void BubbleSort(RecType R[],int n){ int i,j; RecType tmp; for(i=0;i&lt;n-1;i++){ for(j=n-1;j&gt;i;j--){ if(R[i].key&lt;R[j-1].key){ tmp = R[j]; R[j] = R[j-1]; R[j-1] = tmp; } } } }</code><br><strong>算法分析：</strong>若初始数据序列是正序的，则一趟扫描即可完成，所需的关键字比较和元素移动的次数均达到最小值：Cmin = n-1 Mmin = 0，此时时间复杂度为O(n);若初始数据序列是反序的，则需要进行n-i+1次关键字的比较(0&lt;=i&lt;=n-1)，且每次比较都必须移动元素3次来交换元素位置。这时，比较和移动次数都达到最大值：Cmax = O(n2),Mmax = O(n2)。此时，时间复杂度为O(n2)。平均时间复杂度的分析复杂些。因为算法可能在中间某一趟排序完成后就终止，但可以证明平均的排序趟数仍是O(n)，由此得出平均情况下，总的比较次数仍是O(n2),故算法的平均时间复杂度为O(n2)。虽然冒泡排序不一定要进行n-1趟，但由于他的元素移动次数较多，所以平均时间性能比直接插入排序要差。算法中只是用i，j，tmp3个辅助变量，与问题模型n无关，故空间复杂度为O(1)，也就是说，他是一个就地排序。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>排序思路：</strong>快速排序是由冒泡排序改进而得的，他的基本思想是：在待排序的n个元素中任取一个元素(通常取得第一个元素)作为基准，把该元素放入适当位置后，数据序列被此元素划分成两部分，所有关键字小的元素放置在前一部分，所有关键字比他大的元素放置在后一部分，并把该元素排在这两部分的中间(称该元素的归位)，这个过程称作一趟快速排序，之后对所有划分出来的两部分分别重复上述过程，直至每部分内只有一个元素或为空为止。简而言之，每趟将表的第一个元素放入适当位置，将表一分为二，对子表按递归方式继续这种划分，直至划分的子表长为1或0。<br><strong>说明：</strong>快速排序每趟仅将一个元素归位。<br>排序算法： <code>viod QuickSort(RecType R[],int s,int t){ int i=s,j=t; RecType tmp; if(s&lt;t){ tmp = R[s]; while(i!=j){ while(j&gt;i&amp;&amp;R[j].key&gt;=tmp.key) j--; R[i]=R[j]; while(i&lt;j&amp;&amp;R[i].key&lt;=tmp.key) i++; R[j]=R[i]; } R[i] = tmp; QuickSort{R,s,i-1}; QuickSort{R,i-1,t} } }</code><br><strong>算法分析：</strong>平均时间复杂度：O(nlog2 n)，空间复杂度为：O(log2 n)。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><em>选择排序的基本思想是：每一趟从待排序的元素中选出关键字最小的元素，顺序放的已排好序的子表的最后，直到全部元素排序完毕。由于选择排序方法每一趟总是从无序区中选出最小的(或最大的)关键字，所以适用于从较大量的元素中选择一部分排序元素，例如，从10000个元素中选择出关键字大小为前10位的元素，就适合采用选择排序的方法。</em></p><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p><strong>排序思路：</strong>直接选择排序的基本思想是：第i趟排序开始时，当前有序区和无序区分别为R[0..i-1]和R<a href="0&lt;=i&lt;=n-1">i..n-1</a>，该趟排序是从当前无序区选出关键字最小的元素R[k]，将它与无序区的第1个元素R[i]交换，使R[0..i]和R[i+1..n-1]分别变为新的有序区和新的无序区。因为每趟排序均是有序区增加一个元素，且有序区中的元素关键字均不大于无序区中的元素关键字，即第i趟之后，R[0..i]中的所有关键字小于等于R[i+1..n-1]中的所有关键字，所以进行i-1趟排序之后有R[0..n-2]中的所有关键字小于等于R[n-1].key，也就是说，经过n-1趟排序之后，整个表R[0..n-1]递增有序。<br><strong>说明：</strong>直接选择排序每趟产生的有序区一定是全局有序区，也就是说每趟产生的有序区中的所有元素都归位了。<br>排序算法： <code>void SelectSort(RecType R[],int n){ int i,j,k; RecType tmp; for(i=0;i&lt;n-1;i++){ k=i; for(j=i+1;j&lt;n;j++) if(R[j].key&lt;R[k].key) k=j; if(k!=i){ tmp=R[i]; R[i]=R[k]; R[k]=tmp; } } }</code><br><strong>算法分析：</strong>平均时间复杂度：O(n2),空间复杂度O(1)。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>排序思路：</strong>堆排序是一种树形选择排序法，他的特点是，在排序过程中，将R[1..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大(或最小)的元素。<br>堆的定义是：n个关键字序列K1，K2…Kn成为堆。Ki&lt;=K2i且Ki&lt;=K(2i+1)———-小根堆； Ki&gt;=K2i且Ki&gt;=K(2i+1)———-大根堆； 堆排序的排序过程与直接选择排序类似，只是挑选最大或最小元素的不同，这里采用大根堆，每次挑选最大元素归位。挑选最大元素的方法是将数组中储存的数据看成是一棵完全二叉树，利用完全二叉树中双亲节点和孩子节点的内在关系来选择关键字最大元素。具体做法是，把待排序的表的关键字存放在数组R<a href="注意，为了与二叉树的顺序储存结构一致，堆排序的数据序列的下标从1开始">1..n</a>之中，将R看作一棵二叉树，每个节点表示一个元素，原表的第一个元素R[1]作为二叉树的根，一下各元素R[2..n]依次逐层从左到右顺序排列，构成一颗完全二叉树，节点R[i]的左孩子是R[2i]，右孩子是R[2i+1]，双亲是R[i/2]。<br>排序算法： <code>void sift(RecType R[],int low,int high){ int i=low,j=2*i; RecType tmp=R[i]; while(j&lt;=high){ if(j&lt;=high&amp;&amp;R[j].key&lt;R[j+1].key) j++; if(tmp.key&lt;R[j].key){ R[i]=R[j]; i=j; j=2*i; } else break; } R[i]=tmp; } void HeapSort(RecType R[],int n){ int i; RecType tmp; for(i=n/2;i&gt;=i;i--) sift(R,i,n); for(i=n;i&gt;=2;i--){ tmp=R[i]; R[1]=R[i]; R[i]=tmp; sift(R,1,i-1); } }</code><br><strong>算法分析:</strong>平均时间复杂度：O(nlog2 n)，空间复杂度：O(1)。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>排序思路：</strong>归并排序是多次将两个或两个以上的有序表合并成一个新的有序表。最简单的归并是直接将两个有序的子表合并成一个有序的表即二路归并。二路归并排序的基本思路是：将R[0..n-1]看成是n个长度为1的有序序列，然后进行两两归并，得到[n/2]个长度为2(最后一个有序序列长度可能是1)的有序序列，在进行两两归并，得到[n/4]个长度为4(最后一个有序序列长度可能小于4)的有序序列，……，直到得到一个长度为n的有序序列。<br><strong>说明：</strong>归并排序每趟产生的有序区只是局部有序区，也就是说在最后一趟排序结果结束之前，所有元素并不一定归位了。<br>排序算法: <code>void Merge(RecType R[],int low,int mid,int high){ RecType R1; int i=low,j=mid+1,k=0; R1=(RecType *)malloc((high-low+1)*sizeof(RecType)); while(i&lt;=mid&amp;&amp;j&lt;=high) if(R[i].key&lt;=R[j].key){ R1[k]=R[i]; i++;k++; } else{ R1[k]=R[j]; j++;k++; } while(i&lt;=mid){ R1[k]=R[i]; i++;k++; } while(j&lt;=high){ R1[k]=R[j]; j++;k++; } for(k=0,i=low;i&lt;=high;k++,i++) R[i]=R1[k]; free(R1); } void MergePass(RecType R[],int length,int n){ int i; for(i=0;i+2*length-1&lt;n;i=i+2*length) Marge(R,i,i+length-1,i+2*length-1); if(i+length-1&lt;n) Marge(R,i,i+length-1;n-1); } void MergeSort(RecType R[],int i){ int length; for(length=1;length&lt;n;length=2*length) MergePass(R,length,n); }</code><br><strong>算法分析：</strong>平均时间复杂度：O(nlog2 n)，空间复杂度：O(n)。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><strong>排序思路：</strong>通过“分配”和“收集”过程来实实现排序的，不须进行关键字之间的比较，是一种借助多关键字排序的思想对单关键字排序的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在排序过程中，若整个表都是放在内存中处理，排序时不涉及内、外存数据的交换，则称之为内排序。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;p&gt;&lt;em&gt;插入排序的基本思想是：每一次将一个待排序的元素，按其关键字大小插入到已经排好序的字表中的适当位置，知道全部元素插入完成为止。&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
