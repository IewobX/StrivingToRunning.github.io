<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>my blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-13T08:15:00.576Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>徐博伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内排序</title>
    <link href="http://yoursite.com/2017/09/13/%E5%86%85%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/09/13/内排序/</id>
    <published>2017-09-13T07:51:05.000Z</published>
    <updated>2017-09-13T08:15:00.576Z</updated>
    
    <content type="html"><![CDATA[<p><em>在排序过程中，若整个表都是放在内存中处理，排序时不涉及内、外存数据的交换，则称之为内排序。</em></p><h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><p><em>插入排序的基本思想是：每一次将一个待排序的元素，按其关键字大小插入到已经排好序的字表中的适当位置，知道全部元素插入完成为止。</em><br><a id="more"></a></p><h3 id="1-1-直接插入排序"><a href="#1-1-直接插入排序" class="headerlink" title="1.1 直接插入排序"></a>1.1 直接插入排序</h3><p><strong>排序思路：</strong>假设待排序的元素放在数组R[0..n-1]中，排序过程中的某一时刻，R被划分成两个子区间R[0..i-1]和R<a href="刚开始i=1，有序区间只有R[0]一个元素">i..n-1</a>，其中，前一个子区间是已排好序的有序区，后一个子区间则是当前未排序的部分，不妨称其为无需区。直接插入排序的一趟操作是将当前无序区的开头元素R<a href="1&lt;=i&lt;=n-1">i</a>插入带有序区R[0..i-1]中的适当位置上，使R[0..i]变成新的有序区。<br>排序算法： <code>void InsertSort(RecType R[],int n){ int i,j; RecType tmp; for{i=1;i&lt;n;i++}{ tmp = R[i]; j=i-1; while(j&gt;=0&amp;&amp;tmp.key&lt;R[i].key){ R[j+1]=R[j]; j--; } R[j+1] = tmp; } }</code><br><strong>算法分析：</strong>直接插入排序由两重循环构成，对于具有n个元素的表，外循环要进行n-1(i取值范围：1~n-1)趟排序。在每一趟排序中，仅当待插入元素R[i].key&gt;=R[i-1].key(亦即大于等于R[0..i-1]中所有关键字)时,才无需进入内循环。若初始数据序列按关键字递增有序(以下简称“正序”)，则在每一趟排序中仅需进行一次关键字的比较，因为每趟排序均不进入内循环，故不会执行语句R[j+1]=R[j]，此时元素移动次数为2(tmp=R[i]与R[j+1]=tmp各算一次)。由此可知，正序时插入排序的关键字比较次数和元素移动次数均达到最小值Cmin和Mmin。反之，若初始数据序列按关键字递减有序(以下简称“反序”)，则每趟排序中，因为当前有序区R[0..i-1]中的关键字均大于待插元素R[i]的关键字，所以内循环需要将待插元素tmp的关键字和R[0..i-1]中全部的关键字进行比较，这里需要进行i次关键字比较；显然内循环里须将R[0..i-1]中所有元素后移(共(i-1)-0+1=i次)，外加tmp=R[i]与R[i+1]=tmp的两次移动，一趟排序所需的元素移动次数为i+2。由此可知，反序时插入排序的关键字比较次和元素移动次数均达到最大值Cmax和Mmax。由上述分析可知，当初始数据序列不同时，直接插入排序所耗费的时间是有很大差异的，最好的情况是标出态为正序，此时算法的时间复杂度为O(n)，最坏的情况是表初态为反序，相应的时间复杂度为O(n2)。容易证明，算法的平均复杂度为O(n2),这是因为将R<a href="1&lt;=i&lt;=i-1">i</a>插入到有序区R<a href="其中有i个元素">0..i-1</a>时，平均比较次数为i/2，平均移动次数为i/2+2，故平均时间复杂度约为O(n2)。</p><h3 id="1-2-折半插入排序"><a href="#1-2-折半插入排序" class="headerlink" title="1.2 折半插入排序"></a>1.2 折半插入排序</h3><p><strong>排序思路：</strong>直接插入排序将无序区中开头元素R<a href="1&lt;=i&lt;=n-1">i</a>插入到有序区R[0..i-1]中，此时可以采用折半查找的方法先在R[0..i-1]中找到插入位置，在通过移动元素的进行插入，这样的插入排序叫做折半插入排序或二分插入排序。 在R<a href="初始时low=0，high=i-1">low..high</a>中采用折半查找方法查找到插入R[i]的位置为R[high+1]，再将R[high+1..i-1]中元素后移一个位置，并置R[high+1]=R[i]。<br><strong>说明:</strong>和直接插入排序一样，折半插入排序每趟产生的有序区并不一定是全局有序区。<br>排序算法： <code>void Insert1(RecType R[],int n){ int i,j,low,high,mid; RecType tmp; for(i=0;i&lt;n;i++){ tmp = R[i]; low = 0;high = i-1; while(low&lt;=high){ mid = (low+high)/2; if(tmp.key&lt;R[mid].key){ high = mid-1; } else{ low = mid+1; } } for(j=i-1;j&gt;=high+1;j--) R[j+1] = R[j]; R[high+1] = tmp; } }</code><br><strong>算法分析：</strong>从上述算法中看到，当初始数据序列为正序时，关键字的比较次数并不能减少；当初始数据序列为反序时，关键字的比较次数也不会增加。折半插入排序的元素移动次数与直接插入排序相同，不同的仅是变分散移动为集合移动。在R[0..i-1]中查找插入R[i]的位置，折半查找的平均关键字比较次数为log2(i+1)-1,平均的元素移动次数为i/2+2，所以平均时间复杂度为O(n2)。就平均性能而言，折半查找由于顺序查找，所以折半插入排序也优于直接插入排序。折半插入排序的空间复杂度为O(1)。</p><h3 id="1-3-希尔排序"><a href="#1-3-希尔排序" class="headerlink" title="1.3 希尔排序"></a>1.3 希尔排序</h3><p><strong>排序思路：</strong>希尔排序实际上是一种分组插入的方法。其基本思想是：先取定一个小于n的整数d1作为第一个增量，把表的全部元素分成d1个组，所有相互之间距离为d1的倍数的元素放在同一个组中，在个组内进行直接插入排序；然后，取第二个增量d2(<d1)，重复上述的分组和排序过程，直至所取的增量dt=1(dt<dt-1<...<d2<d1)，即所有元素放在同一组中进行直接插入排序。 **说明：**希尔排序每趟并不产生有序区，在最后一趟排序结束前，所有元素并不一定归位。但是每趟排序完成后，数据越来越接近有序。="" **排序算法：**取d1="n/2，di+1=[di/2]时的希尔排序的算法如下：" ``void="" shellsort(rectype="" r[],int="" n){="" int="" i,j,jap;="" rectype="" tmp;="" gap="n/2;" while(gap="">0){ for(i=gap;i<n;i++){ tmp="R[i];" j="i-gap;" while(j="">=0&amp;&amp;tmp.key&lt;R[j].key){ R[j+gap] = R[j]; j=j-gap; } R[j+gap]=tmp; } gap=gap/2; } }``<br><strong>算法分析：</strong>希尔排序法的性能分析是一个复杂的问题，因为它的时间复杂度是所取增量序列的函数，而且到目前为止增量的选取无一定论。但无论增量如何选取，最后一个增量必须是1。如果按照上述取法，一般认为希尔算法的平均时间复杂度是O(n^1.3)。希尔排序的速度一般要比直接插入排序快。 希尔算法只是用i,j,gap,tmp四个辅助变量，与问题规模n无关，所以空间复杂度为O(1),也就是说，他是一个就地排序。</n;i++){></d1)，重复上述的分组和排序过程，直至所取的增量dt=1(dt<dt-1<...<d2<d1)，即所有元素放在同一组中进行直接插入排序。></p><h2 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2.交换排序"></a>2.交换排序</h2><p><em>交换排序的基本思想：两两比较待排序元素的关键字，发现两个元素的次序相反时即进行交换，知道没有反序的元素为止。</em></p><h3 id="2-1冒泡排序"><a href="#2-1冒泡排序" class="headerlink" title="2.1冒泡排序"></a>2.1冒泡排序</h3><p><strong>排序思路：</strong>通过无需区中相邻元素间的关键字的比较和位置的交换，使关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”。整个过程是从最下面的元素开始，对每两个相邻的关键字进行比较，且使关键字较小的元素换至关键字较大的元素之上，使得经过一趟冒泡排序之后，关键字最小的元素到了最上端。接着，再在剩下的元素中找关键字次小的元素，并把它换到第二个位置。以此类推，一直到所有元素都有续为止。<br><strong>说明：</strong>冒泡排序每趟产生的有序区一定是全局有序区，也就是说每趟产生的有序区中所有元素都归位了。<br>排序算法： <code>void BubbleSort(RecType R[],int n){ int i,j; RecType tmp; for(i=0;i&lt;n-1;i++){ for(j=n-1;j&gt;i;j--){ if(R[i].key&lt;R[j-1].key){ tmp = R[j]; R[j] = R[j-1]; R[j-1] = tmp; } } } }</code><br><strong>算法分析：</strong>若初始数据序列是正序的，则一趟扫描即可完成，所需的关键字比较和元素移动的次数均达到最小值：Cmin = n-1 Mmin = 0，此时时间复杂度为O(n);若初始数据序列是反序的，则需要进行n-i+1次关键字的比较(0&lt;=i&lt;=n-1)，且每次比较都必须移动元素3次来交换元素位置。这时，比较和移动次数都达到最大值：Cmax = O(n2),Mmax = O(n2)。此时，时间复杂度为O(n2)。平均时间复杂度的分析复杂些。因为算法可能在中间某一趟排序完成后就终止，但可以证明平均的排序趟数仍是O(n)，由此得出平均情况下，总的比较次数仍是O(n2),故算法的平均时间复杂度为O(n2)。虽然冒泡排序不一定要进行n-1趟，但由于他的元素移动次数较多，所以平均时间性能比直接插入排序要差。算法中只是用i，j，tmp3个辅助变量，与问题模型n无关，故空间复杂度为O(1)，也就是说，他是一个就地排序。</p><h3 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h3><p><strong>排序思路：</strong>快速排序是由冒泡排序改进而得的，他的基本思想是：在待排序的n个元素中任取一个元素(通常取得第一个元素)作为基准，把该元素放入适当位置后，数据序列被此元素划分成两部分，所有关键字小的元素放置在前一部分，所有关键字比他大的元素放置在后一部分，并把该元素排在这两部分的中间(称该元素的归位)，这个过程称作一趟快速排序，之后对所有划分出来的两部分分别重复上述过程，直至每部分内只有一个元素或为空为止。简而言之，每趟将表的第一个元素放入适当位置，将表一分为二，对子表按递归方式继续这种划分，直至划分的子表长为1或0。<br><strong>说明：</strong>快速排序每趟仅将一个元素归位。<br>排序算法： <code>viod QuickSort(RecType R[],int s,int t){ int i=s,j=t; RecType tmp; if(s&lt;t){ tmp = R[s]; while(i!=j){ while(j&gt;i&amp;&amp;R[j].key&gt;=tmp.key) j--; R[i]=R[j]; while(i&lt;j&amp;&amp;R[i].key&lt;=tmp.key) i++; R[j]=R[i]; } R[i] = tmp; QuickSort{R,s,i-1}; QuickSort{R,i-1,t} } }</code><br><strong>算法分析：</strong>平均时间复杂度：O(nlog2 n)，空间复杂度为：O(log2 n)。</p><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h2><p><em>选择排序的基本思想是：每一趟从待排序的元素中选出关键字最小的元素，顺序放的已排好序的子表的最后，直到全部元素排序完毕。由于选择排序方法每一趟总是从无序区中选出最小的(或最大的)关键字，所以适用于从较大量的元素中选择一部分排序元素，例如，从10000个元素中选择出关键字大小为前10位的元素，就适合采用选择排序的方法。</em></p><h3 id="3-1直接选择排序"><a href="#3-1直接选择排序" class="headerlink" title="3.1直接选择排序"></a>3.1直接选择排序</h3><p><strong>排序思路：</strong>直接选择排序的基本思想是：第i趟排序开始时，当前有序区和无序区分别为R[0..i-1]和R<a href="0&lt;=i&lt;=n-1">i..n-1</a>，该趟排序是从当前无序区选出关键字最小的元素R[k]，将它与无序区的第1个元素R[i]交换，使R[0..i]和R[i+1..n-1]分别变为新的有序区和新的无序区。因为每趟排序均是有序区增加一个元素，且有序区中的元素关键字均不大于无序区中的元素关键字，即第i趟之后，R[0..i]中的所有关键字小于等于R[i+1..n-1]中的所有关键字，所以进行i-1趟排序之后有R[0..n-2]中的所有关键字小于等于R[n-1].key，也就是说，经过n-1趟排序之后，整个表R[0..n-1]递增有序。<br><strong>说明：</strong>直接选择排序每趟产生的有序区一定是全局有序区，也就是说每趟产生的有序区中的所有元素都归位了。<br>排序算法： <code>void SelectSort(RecType R[],int n){ int i,j,k; RecType tmp; for(i=0;i&lt;n-1;i++){ k=i; for(j=i+1;j&lt;n;j++) if(R[j].key&lt;R[k].key) k=j; if(k!=i){ tmp=R[i]; R[i]=R[k]; R[k]=tmp; } } }</code><br><strong>算法分析：</strong>平均时间复杂度：O(n2),空间复杂度O(1)。</p><h3 id="3-2堆排序"><a href="#3-2堆排序" class="headerlink" title="3.2堆排序"></a>3.2堆排序</h3><p><strong>排序思路：</strong>堆排序是一种树形选择排序法，他的特点是，在排序过程中，将R[1..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大(或最小)的元素。<br>堆的定义是：n个关键字序列K1，K2…Kn成为堆。Ki&lt;=K2i且Ki&lt;=K(2i+1)———-小根堆； Ki&gt;=K2i且Ki&gt;=K(2i+1)———-大根堆； 堆排序的排序过程与直接选择排序类似，只是挑选最大或最小元素的不同，这里采用大根堆，每次挑选最大元素归位。挑选最大元素的方法是将数组中储存的数据看成是一棵完全二叉树，利用完全二叉树中双亲节点和孩子节点的内在关系来选择关键字最大元素。具体做法是，把待排序的表的关键字存放在数组R<a href="注意，为了与二叉树的顺序储存结构一致，堆排序的数据序列的下标从1开始">1..n</a>之中，将R看作一棵二叉树，每个节点表示一个元素，原表的第一个元素R[1]作为二叉树的根，一下各元素R[2..n]依次逐层从左到右顺序排列，构成一颗完全二叉树，节点R[i]的左孩子是R[2i]，右孩子是R[2i+1]，双亲是R[i/2]。<br>排序算法： <code>void sift(RecType R[],int low,int high){ int i=low,j=2*i; RecType tmp=R[i]; while(j&lt;=high){ if(j&lt;=high&amp;&amp;R[j].key&lt;R[j+1].key) j++; if(tmp.key&lt;R[j].key){ R[i]=R[j]; i=j; j=2*i; } else break; } R[i]=tmp; } void HeapSort(RecType R[],int n){ int i; RecType tmp; for(i=n/2;i&gt;=i;i--) sift(R,i,n); for(i=n;i&gt;=2;i--){ tmp=R[i]; R[1]=R[i]; R[i]=tmp; sift(R,1,i-1); } }</code><br><strong>算法分析:</strong>平均时间复杂度：O(nlog2 n)，空间复杂度：O(1)。</p><h2 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h2><p><strong>排序思路：</strong>归并排序是多次将两个或两个以上的有序表合并成一个新的有序表。最简单的归并是直接将两个有序的子表合并成一个有序的表即二路归并。二路归并排序的基本思路是：将R[0..n-1]看成是n个长度为1的有序序列，然后进行两两归并，得到[n/2]个长度为2(最后一个有序序列长度可能是1)的有序序列，在进行两两归并，得到[n/4]个长度为4(最后一个有序序列长度可能小于4)的有序序列，……，直到得到一个长度为n的有序序列。<br><strong>说明：</strong>归并排序每趟产生的有序区只是局部有序区，也就是说在最后一趟排序结果结束之前，所有元素并不一定归位了。<br>排序算法: <code>void Merge(RecType R[],int low,int mid,int high){ RecType R1; int i=low,j=mid+1,k=0; R1=(RecType *)malloc((high-low+1)*sizeof(RecType)); while(i&lt;=mid&amp;&amp;j&lt;=high) if(R[i].key&lt;=R[j].key){ R1[k]=R[i]; i++;k++; } else{ R1[k]=R[j]; j++;k++; } while(i&lt;=mid){ R1[k]=R[i]; i++;k++; } while(j&lt;=high){ R1[k]=R[j]; j++;k++; } for(k=0,i=low;i&lt;=high;k++,i++) R[i]=R1[k]; free(R1); } void MergePass(RecType R[],int length,int n){ int i; for(i=0;i+2*length-1&lt;n;i=i+2*length) Marge(R,i,i+length-1,i+2*length-1); if(i+length-1&lt;n) Marge(R,i,i+length-1;n-1); } void MergeSort(RecType R[],int i){ int length; for(length=1;length&lt;n;length=2*length) MergePass(R,length,n); }</code><br><strong>算法分析：</strong>平均时间复杂度：O(nlog2 n)，空间复杂度：O(n)。</p><p>##5.基数排序##<br><strong>排序思路：</strong>通过“分配”和“收集”过程来实实现排序的，不须进行关键字之间的比较，是一种借助多关键字排序的思想对单关键字排序的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在排序过程中，若整个表都是放在内存中处理，排序时不涉及内、外存数据的交换，则称之为内排序。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-插入排序&quot;&gt;&lt;a href=&quot;#1-插入排序&quot; class=&quot;headerlink&quot; title=&quot;1.插入排序&quot;&gt;&lt;/a&gt;1.插入排序&lt;/h2&gt;&lt;p&gt;&lt;em&gt;插入排序的基本思想是：每一次将一个待排序的元素，按其关键字大小插入到已经排好序的字表中的适当位置，知道全部元素插入完成为止。&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/09/11/hello-world/"/>
    <id>http://yoursite.com/2017/09/11/hello-world/</id>
    <published>2017-09-11T13:07:18.932Z</published>
    <updated>2017-09-11T13:07:18.932Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
